/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client/game.ts":
/*!****************************!*\
  !*** ./src/client/game.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SCALE = void 0;\nconst helpers = __importStar(__webpack_require__(/*! ./helpers */ \"./src/client/helpers.ts\"));\nconst sprites_1 = __webpack_require__(/*! ./sprites */ \"./src/client/sprites.ts\");\nconst tiles_1 = __webpack_require__(/*! ./tiles */ \"./src/client/tiles.ts\");\nconst MIN_SCALE = 1.0;\nconst MAX_SCALE = 7.0;\nexports.SCALE = 2.500;\nlet cameraOffsetX = 0;\nlet cameraOffsetY = 100;\nlet arenaImage = null;\nlet arena = null;\nlet uiImage = new Image();\nuiImage.src = '/assets/spritesheets/UI.png';\nlet players = [];\nlet units = [];\nlet tiles = [];\nlet visibleTiles = [];\nlet hoveredTile = null;\nlet selectedTile = null;\nlet moveTile = null;\nlet validMoveTiles = [];\nlet actionTile = null;\nlet validActionTiles = [];\nlet currentRound = 0;\nlet player1Time = 0;\nlet player2Time = 0;\nlet isAction = false;\nlet isAnimating = false;\nlet animatingUnit;\nlet animateHealthBar = false;\nlet animatingHealthBarUnit = null;\nlet healthBarCurrent;\nconst endTurnBtn = document.getElementById('endTurnBtn');\nconst gameOverUI = document.getElementById('gameOver');\nlet gameOver = false;\nconst canvas = document.getElementById('gameCanvas');\nconst ctx = canvas.getContext('2d');\nfunction gameLoop() {\n    draw();\n    requestAnimationFrame(gameLoop);\n}\ngameLoop();\nfunction loadUnits(players) {\n    const updatedOrAddedUnitIds = new Set();\n    for (const player of players) {\n        for (const unit of player.units) {\n            const existingUnit = units.find(u => u.id === unit.id);\n            if (existingUnit) {\n                if (animatingUnit && animatingUnit.id === unit.id && animatingUnit.owner === player) {\n                    existingUnit.row = unit.row;\n                    existingUnit.col = unit.col;\n                }\n                existingUnit.health = unit.health;\n                existingUnit.canMove = unit.canMove;\n                existingUnit.canAct = unit.canAct;\n                existingUnit.currentStatus = !unit.canMove && !unit.canAct ? 1 : 0;\n                updatedOrAddedUnitIds.add(existingUnit.id);\n            }\n            else {\n                unit.owner = player;\n                const newSprite = sprites_1.sprites.find(sprite => sprite.name === unit.name) || sprites_1.sprites[0];\n                if (newSprite)\n                    unit.sprite = newSprite.copy();\n                unit.currentStatus = unit.canMove || unit.canAct ? 0 : 1;\n                units.push(unit);\n                updatedOrAddedUnitIds.add(unit.id);\n            }\n        }\n    }\n    if (!animatingUnit)\n        units = units.filter(unit => updatedOrAddedUnitIds.has(unit.id));\n}\nfunction loadPlayers(newPlayers) {\n    players = [];\n    players = newPlayers;\n    if (players.length === 2) {\n        if (isTurn())\n            endTurnBtn.disabled = false;\n        else\n            endTurnBtn.disabled = true;\n    }\n}\nfunction loadArenaImage(newArena) {\n    if (!arenaImage) {\n        arenaImage = new Image();\n        arenaImage.src = `/assets/maps/${newArena.name}.png`;\n        arena = newArena;\n        arenaImage.onload = () => {\n            drawArena();\n        };\n    }\n}\nfunction resizeCanvas() {\n    canvas.width = window.outerWidth;\n    canvas.height = window.innerHeight;\n    draw();\n}\nresizeCanvas();\nwindow.addEventListener('resize', resizeCanvas);\nwindow.addEventListener('orientationchange', resizeCanvas);\nfunction animateMove(tempUnit, origin, target) {\n    return __awaiter(this, void 0, void 0, function* () {\n        isAnimating = true;\n        const path = astarPath(origin.row, origin.col, target.row, target.col);\n        const realUnit = units.find(unit => unit.row === tempUnit.row && unit.col === tempUnit.col);\n        if (!realUnit)\n            return;\n        for (const tile of path) {\n            if (!isAnimating)\n                break;\n            animatingUnit = realUnit;\n            realUnit.currentStatus = 2;\n            realUnit.sprite.currentFrame = 0;\n            // play footstep sound\n            realUnit.row = tile.y;\n            realUnit.col = tile.x;\n            yield sleep(100);\n        }\n        isAnimating = false;\n        animatingUnit = null;\n        realUnit.currentStatus = 0;\n        realUnit.sprite.currentFrame = 0;\n    });\n}\n// -----------Socket Events--------------------------------\nwindow.socket.on('game-code', (data) => {\n    const gameCode = document.getElementById('gameCode');\n    if (!gameCode)\n        return;\n    gameCode.textContent = data.code;\n});\nwindow.socket.on('invalid-code', () => {\n    alert(\"Invalid Code. Please try again.\");\n});\nwindow.socket.on('gameState', (gameState) => {\n    loadArenaImage(gameState.arena); // move to a game start function in the future to only load once\n    loadPlayers(gameState.players);\n    loadUnits(gameState.players);\n    visibleTiles = gameState.visibleTiles;\n    currentRound = gameState.round;\n    player1Time = gameState.player1Time;\n    player2Time = gameState.player2Time;\n});\nwindow.socket.on('gameOver', (player) => {\n    const gameOverMsg = document.getElementById('gameOverMsg');\n    if (!gameOverMsg)\n        return;\n    if (player.socket !== window.socket.id) {\n        gameOverMsg.innerHTML = \"YOU LOSE...\";\n    }\n    else {\n        gameOverMsg.innerHTML = \"YOU WIN!\";\n    }\n    gameOver = true;\n});\nwindow.socket.on('nextRound', (player) => {\n    const nextRoundMsg = document.getElementById('nextRoundMsg');\n    if (!nextRoundMsg)\n        return;\n    const nextTurnBG = document.getElementById('nextTurnBG');\n    if (!nextTurnBG)\n        return;\n    if (player.socket !== window.socket.id) {\n        nextRoundMsg.innerHTML = \"ENEMY TURN\";\n        nextTurnBG.classList.add(\"border-red-500\");\n        nextTurnBG.classList.remove(\"border-blue-500\");\n    }\n    else {\n        nextRoundMsg.innerHTML = \"YOUR TURN\";\n        nextTurnBG.classList.add(\"border-blue-500\");\n        nextTurnBG.classList.remove(\"border-red-500\");\n        if (document.hidden) {\n            alert('It is now your turn.');\n        }\n    }\n    const nextTurnDiv = document.getElementById(\"nextTurn\");\n    nextTurnDiv.classList.toggle(\"top-full\");\n    nextTurnDiv.classList.toggle(\"top-0\");\n    setTimeout(() => {\n        nextTurnDiv.classList.toggle(\"top-full\");\n        nextTurnDiv.classList.toggle(\"top-0\");\n    }, 4000);\n});\nwindow.socket.on('player-unit-moving', (unit, origin, target) => {\n    const isUnitVisible = units.find(u => u.row === unit.row && u.col === unit.col);\n    if (!isUnitVisible)\n        return;\n    isAction = true;\n    animateMove(unit, origin, target);\n    moveTile = target;\n});\nwindow.socket.on('animate-healthbar', (unit, healthBefore, healthAfter) => {\n    const isUnitVisible = units.find(u => u.row === unit.row && u.col === unit.col);\n    if (!isUnitVisible)\n        return;\n    const action = healthBefore < healthAfter ? \"attack\" : \"heal\";\n    // depending on action, play different audio\n    animateHealthBar = true;\n    animatingHealthBarUnit = unit;\n    healthBarCurrent = healthBefore;\n    const healthDiff = healthAfter - healthBefore;\n    const healthTick = healthDiff / 5;\n    const interval = setInterval(() => {\n        healthBarCurrent += healthTick;\n    }, 100);\n    setTimeout(() => {\n        animateHealthBar = false;\n        animatingHealthBarUnit = null;\n        clearInterval(interval);\n    }, 600);\n});\n// -----------Drawing Functions----------------------------\nfunction drawBackground() {\n    ctx.fillStyle = '#222034';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n}\nfunction drawArena() {\n    if (arenaImage) {\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(arenaImage, (canvas.width - arena.width * exports.SCALE) / 2 + cameraOffsetX, (canvas.height - arena.height * exports.SCALE - 16 * exports.SCALE) / 2 + cameraOffsetY, arena.width * exports.SCALE, arena.height * exports.SCALE);\n    }\n}\nfunction draw() {\n    if (!gameOver)\n        gameOverUI.style.display = 'none';\n    else\n        gameOverUI.style.display = 'flex';\n    const loading = document.getElementById('loading');\n    if (loading && players.length === 2)\n        loading.style.display = 'none';\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    drawBackground();\n    drawArena();\n    drawFogOfWarTiles();\n    drawEntities();\n    drawUI();\n    drawInteractionSquares();\n    editHTML();\n}\nfunction drawEntities() {\n    if (!arena)\n        return;\n    const entities = [\n        ...arena.obstacles.map(obstacle => ({ type: 'obstacle', entity: obstacle })),\n        ...units.map(unit => ({ type: 'unit', entity: unit }))\n    ];\n    entities.sort((a, b) => {\n        if (a.entity.row !== b.entity.row) {\n            return a.entity.row - b.entity.row;\n        }\n        return a.entity.col - b.entity.col;\n    });\n    for (const { type, entity } of entities) {\n        const pos = coordToPosition(entity.row, entity.col);\n        if (type === 'obstacle') {\n            const obstacle = entity;\n            const frameSize = obstacle.sprite.height;\n            const frameX = 0;\n            const frameY = 0;\n            const sx = frameX * frameSize;\n            const sy = frameY * frameSize;\n            ctx.imageSmoothingEnabled = false;\n            ctx.globalAlpha = 0.90;\n            let obstacleImage = new Image();\n            obstacleImage.src = `/assets/maps/${obstacle.sprite.name}.png`;\n            ctx.drawImage(obstacleImage, sx, sy, frameSize, frameSize, pos.x - 32 * exports.SCALE, pos.y - frameSize * exports.SCALE + (8 * exports.SCALE), frameSize * exports.SCALE, frameSize * exports.SCALE);\n            obstacle.sprite.framesElapsed++;\n            if (obstacle.sprite.framesElapsed % obstacle.sprite.framesHold === 0) {\n                if (obstacle.sprite.currentFrame < obstacle.sprite.idleFrames - 1) {\n                    obstacle.sprite.currentFrame++;\n                }\n                else {\n                    obstacle.sprite.currentFrame = 0;\n                }\n            }\n            ctx.globalAlpha = 1.0;\n        }\n        else if (type === 'unit') {\n            const unit = entity;\n            const frameSize = 32;\n            const frameX = unit.sprite.currentFrame;\n            const frameY = unit.currentStatus;\n            const sx = frameX * frameSize;\n            const sy = frameY * frameSize;\n            ctx.imageSmoothingEnabled = false;\n            let unitImage = new Image();\n            unitImage.src = `/assets/spritesheets/units/${unit.sprite.name}.png`;\n            ctx.drawImage(unitImage, sx, sy, frameSize, frameSize, pos.x, pos.y - frameSize * exports.SCALE + (8 * exports.SCALE), frameSize * exports.SCALE, frameSize * exports.SCALE);\n            unit.sprite.framesElapsed++;\n            if (unit.sprite.framesElapsed % unit.sprite.framesHold === 0) {\n                if (unit.sprite.currentFrame < unit.sprite.idleFrames - 1) {\n                    unit.sprite.currentFrame++;\n                }\n                else {\n                    unit.sprite.currentFrame = 0;\n                }\n            }\n        }\n    }\n}\nfunction drawUI() {\n    drawHoveredTile();\n    drawSelectedTile();\n    drawMovementTiles();\n    drawActionTiles();\n    drawPath();\n    drawHealthBars();\n    drawAnimatingHealthBar();\n    //drawTileInfo();\n    drawHoveredUnitName();\n}\nfunction editHTML() {\n    if (players.length < 2)\n        return;\n    const player1BG = document.getElementById('player1');\n    const player2BG = document.getElementById('player2');\n    if (players[0].socket === window.socket.id) {\n        player1BG.classList.add(\"bg-blue-600\");\n        player1BG.classList.remove(\"bg-red-600\");\n        player1BG.classList.add(\"border-blue-400\");\n        player1BG.classList.remove(\"boarder-red-400\");\n        player2BG.classList.add(\"bg-red-600\");\n        player2BG.classList.remove(\"bg-blue-600\");\n        player2BG.classList.add(\"border-red-400\");\n        player2BG.classList.remove(\"boarder-blue-400\");\n    }\n    else {\n        player2BG.classList.add(\"bg-blue-600\");\n        player2BG.classList.remove(\"bg-red-600\");\n        player2BG.classList.add(\"border-blue-400\");\n        player2BG.classList.remove(\"boarder-red-400\");\n        player1BG.classList.add(\"bg-red-600\");\n        player1BG.classList.remove(\"bg-blue-600\");\n        player1BG.classList.add(\"border-red-400\");\n        player1BG.classList.remove(\"boarder-blue-400\");\n    }\n    const player1Name = document.getElementById('player1Name');\n    const player2Name = document.getElementById('player2Name');\n    player1Name.innerHTML = players[0].name;\n    player2Name.innerHTML = players[1].name;\n    const player1ProfilePic = document.getElementById('player1ProfilePic');\n    const player2ProfilePic = document.getElementById('player2ProfilePic');\n    player1ProfilePic.src = `/assets/profileimages/${players[0].profileimage}.png`;\n    player2ProfilePic.src = `/assets/profileimages/${players[1].profileimage}.png`;\n    const player1Timer = document.getElementById('player1Time');\n    const player2Timer = document.getElementById('player2Time');\n    const player1FormattedTime = formatTime(player1Time);\n    const player2FormattedTime = formatTime(player2Time);\n    player1Timer.innerHTML = player1FormattedTime;\n    player2Timer.innerHTML = player2FormattedTime;\n}\nfunction drawInteractionSquares() {\n    if (!arenaImage)\n        return;\n    if (!arena)\n        return;\n    const tileWidth = 32 * exports.SCALE; // width of an isometric tile\n    const tileHeight = 16 * exports.SCALE; // height of an isometric tile\n    const rows = arena.tiles.length;\n    const cols = arena.tiles[0].length;\n    // get canvas center\n    const imgCenterX = canvas.width / 2;\n    const imgCenterY = canvas.height / 2;\n    // Calculate the total width and height of the grid\n    const gridWidth = (cols - 1) * tileWidth / 2; // Total width of the grid\n    const gridHeight = (rows - 1) * tileHeight / 2; // Total height of the grid\n    // Calculate the offset to center the grid on the image\n    const offsetX = imgCenterX - tileWidth / 2 + cameraOffsetX;\n    const offsetY = imgCenterY - gridHeight - tileHeight - 8 * exports.SCALE + cameraOffsetY;\n    // Draw the tiles\n    tiles = [];\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            // Calculate isometric coordinates\n            if (arena.tiles[row][col] === 0)\n                continue;\n            const isoX = (col - row) * tileWidth / 2 + offsetX;\n            const isoY = (col + row) * tileHeight / 2 + offsetY - ((getTileHeight(row, col) * 16) * exports.SCALE);\n            tiles.push(drawIsometricTile(isoX, isoY, row, col));\n        }\n    }\n}\nfunction drawIsometricTile(x, y, row, col) {\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + 16 * exports.SCALE, y + 8 * exports.SCALE);\n    ctx.lineTo(x + 32 * exports.SCALE, y);\n    ctx.lineTo(x + 16 * exports.SCALE, y - 8 * exports.SCALE);\n    ctx.closePath();\n    //ctx.stroke();\n    return { x, y, row, col };\n}\nfunction drawHoveredTile() {\n    if (!hoveredTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = hasUnit(hoveredTile.row, hoveredTile.col) ? (unitIsTeam(hoveredTile.row, hoveredTile.col) ? 1 : 2) : 0;\n    const highlightFrameY = 0;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, hoveredTile.x, hoveredTile.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawSelectedTile() {\n    if (!selectedTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = 3;\n    const highlightFrameY = 0;\n    const col = selectedTile.col;\n    const row = selectedTile.row;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawTileInfo() {\n    if (!arena)\n        return;\n    if (!hoveredTile)\n        return;\n    const bgWidth = 256;\n    const bgHeight = 64;\n    const margin = 10;\n    const padding = 10;\n    const squareX = 0;\n    const squareY = margin + (64 * 4);\n    const terrain = arena.tiles[hoveredTile.row][hoveredTile.col];\n    const terrainType = tiles_1.tileTypes.find(tile => tile.id === terrain);\n    if (!terrainType)\n        return;\n    ctx.fillStyle = '#45283c';\n    ctx.fillRect(squareX, squareY, bgWidth, bgHeight); // replace with tile info ui back image\n    ctx.fillStyle = 'white';\n    ctx.font = '42px \"VT323\"';\n    ctx.fillText(terrainType.name.toUpperCase(), squareX + padding, squareY + padding + 34);\n}\nfunction drawHoveredUnitName() {\n    if (!arena)\n        return;\n    if (!hoveredTile)\n        return;\n    if (!hasUnit(hoveredTile.row, hoveredTile.col))\n        return;\n    const margin = 10;\n    const padding = 10;\n    const statLabelHeight = 30;\n    const squareX = 0;\n    const squareY = canvas.height - (64 * 5) - margin;\n    const hoveredUnit = units.find(unit => unit.row === hoveredTile.row && unit.col === hoveredTile.col);\n    if (!hoveredUnit)\n        return;\n    const nameWidth = hoveredUnit.name.length * 24 + 6 * padding;\n    const statsWidth = Math.max(ctx.measureText('HP:' + hoveredUnit.health.toString() + '/' + hoveredUnit.maxHealth.toString()).width, ctx.measureText('Atk:' + hoveredUnit.attack.toString() + ' Def:' + hoveredUnit.defense.toString()).width, ctx.measureText('Rng:' + hoveredUnit.range.toString() + '/' + ' Mob:' + hoveredUnit.mobility.toString()).width);\n    const bgWidth = Math.max(nameWidth, statsWidth) + 2 * padding;\n    const bgHeight = 64 + 3 * statLabelHeight;\n    ctx.fillStyle = '#45283c';\n    ctx.fillRect(squareX, squareY, bgWidth, bgHeight);\n    ctx.fillStyle = 'white';\n    ctx.font = '42px \"VT323\"';\n    ctx.fillText(hoveredUnit.name.toUpperCase(), squareX + padding, squareY + padding + 34);\n    ctx.font = '24px \"VT323\"';\n    const statLabels = [\n        `HP:${Math.round(hoveredUnit.health)}/${hoveredUnit.maxHealth}`,\n        `Atk:${hoveredUnit.attack} Def:${hoveredUnit.defense}`,\n        `Rng:${hoveredUnit.range} Mob:${hoveredUnit.mobility}`,\n    ];\n    statLabels.forEach((label, index) => {\n        ctx.fillText(label, squareX + padding, squareY + padding + 34 + (index + 1) * statLabelHeight);\n    });\n}\nfunction drawFogOfWarTiles() {\n    if (!arena)\n        return;\n    for (let row = 0; row < arena.tiles.length; row++) {\n        for (let col = 0; col < arena.tiles[row].length; col++) {\n            if (arena.tiles[row][col] === 0)\n                continue;\n            if (isVisibleTile(row, col))\n                continue;\n            drawFogOfWarTile(row, col);\n        }\n    }\n}\nfunction drawFogOfWarTile(row, col) {\n    const frameSize = 32;\n    const highlightFrameX = 4;\n    const highlightFrameY = 1;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawHealthBars() {\n    if ((!isAction && !selectedTile || animatingUnit))\n        return;\n    for (const unit of units) {\n        const pos = coordToPosition(unit.row, unit.col);\n        if (pos.x === -9999 || pos.y === -9999)\n            return;\n        const barHeight = 2 * exports.SCALE;\n        const barWidth = 12 * exports.SCALE;\n        const barX = pos.x + barWidth - (2 * exports.SCALE);\n        const barY = pos.y - 16 * exports.SCALE;\n        ctx.fillStyle = '#555';\n        ctx.fillRect(barX, barY, barWidth, barHeight);\n        const healthWidth = barWidth * (unit.health / unit.maxHealth);\n        ctx.fillStyle = '#0f0';\n        ctx.fillRect(barX, barY, healthWidth, barHeight);\n    }\n}\nfunction drawAnimatingHealthBar() {\n    if (!animateHealthBar)\n        return;\n    if (!animatingHealthBarUnit)\n        return;\n    const unit = animatingHealthBarUnit;\n    const pos = coordToPosition(unit.row, unit.col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    const barHeight = 2 * exports.SCALE;\n    const barWidth = 12 * exports.SCALE;\n    const barX = pos.x + barWidth - (2 * exports.SCALE);\n    const barY = pos.y - 16 * exports.SCALE;\n    ctx.fillStyle = '#555';\n    ctx.fillRect(barX, barY, barWidth, barHeight);\n    const healthWidth = barWidth * (healthBarCurrent / unit.maxHealth);\n    ctx.fillStyle = '#0f0';\n    ctx.fillRect(barX, barY, healthWidth, barHeight);\n}\nfunction drawMovementTiles() {\n    if (!arena)\n        return;\n    if (selectedTile) {\n        const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n        if (unit) {\n            validMoveTiles = [];\n            const mobility = unit.mobility;\n            const range = unit.range;\n            const row = selectedTile.row;\n            const col = selectedTile.col;\n            let mobilityTiles = [];\n            for (let i = -mobility; i <= mobility; i++) {\n                for (let j = -mobility; j <= mobility; j++) {\n                    if (Math.abs(i) + Math.abs(j) <= mobility) {\n                        const targetRow = row + i;\n                        const targetCol = col + j;\n                        if (targetRow < 0 || targetCol < 0 || targetRow >= arena.tiles.length || targetCol >= arena.tiles[0].length)\n                            continue;\n                        if (hasUnit(targetRow, targetCol) && (i !== 0 || j !== 0))\n                            continue;\n                        const targetTerrain = arena.tiles[targetRow][targetCol];\n                        if (targetTerrain === 0)\n                            continue;\n                        // Check the path for obstacles or terrain that blocks movement\n                        const path = astarPath(row, col, targetRow, targetCol);\n                        if (path.length - 1 > mobility)\n                            continue;\n                        if (path.length === 0)\n                            continue;\n                        let canMove = true;\n                        let mobilityPenalty = 0;\n                        for (const tile of path) {\n                            const terrain = arena.tiles[tile.y][tile.x];\n                            if ((row !== tile.y && col !== tile.x) && hasUnit(tile.y, tile.x)) {\n                                canMove = false;\n                                break;\n                            }\n                            else if (terrain === 0) {\n                                canMove = false;\n                                break;\n                            }\n                            else if (terrain === 2) {\n                                mobilityPenalty += 2;\n                            }\n                            else if (terrain === 3) {\n                            }\n                            else if (terrain === 4) {\n                                console.log(\"obstacle detected\");\n                                canMove = false;\n                                break;\n                            }\n                        }\n                        if (canMove && (mobility - mobilityPenalty >= 0)) {\n                            mobilityTiles.push({ x: targetRow, y: targetCol });\n                            drawMoveTile(targetRow, targetCol);\n                        }\n                    }\n                }\n            }\n            //Second loop: Draw attack range borders\n            for (let tile of mobilityTiles) {\n                const mobilityTileRow = tile.x;\n                const mobilityTileCol = tile.y;\n                for (let i = -range; i <= range; i++) {\n                    for (let j = -range; j <= range; j++) {\n                        if (Math.abs(i) + Math.abs(j) <= range) {\n                            let action = unit.action;\n                            const targetRow = mobilityTileRow + i;\n                            const targetCol = mobilityTileCol + j;\n                            if (targetRow === row && targetCol === col)\n                                continue;\n                            if (mobilityTiles.find(tile => tile.x === targetRow && tile.y === targetCol))\n                                continue;\n                            if (hasUnit(targetRow, targetCol))\n                                continue;\n                            if (targetRow >= 0 && targetRow < arena.tiles.length && targetCol >= 0 && targetCol < arena.tiles[0].length) {\n                                // Check the path for tiles that can restrict visibility\n                                const path = bresenhamPath(mobilityTileRow, mobilityTileCol, targetRow, targetCol);\n                                let canSee = true;\n                                let rangePenalty = 0;\n                                for (const tile of path) {\n                                    if (arena.tiles) {\n                                        const terrain = arena.tiles[tile.y][tile.x];\n                                        if (terrain === 3) {\n                                            if (!adjacentTile(row, col, tile.y, tile.x)) {\n                                                canSee = false;\n                                                break;\n                                            }\n                                        }\n                                        if (terrain === 4) {\n                                            canSee = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (canSee && (range - rangePenalty >= 0)) {\n                                    drawActionTile(targetRow, targetCol, action);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n// turn into arrow\nfunction drawPath() {\n    if (!selectedTile)\n        return;\n    if (!hoveredTile)\n        return;\n    if (!validMoveTiles)\n        return;\n    const path = astarPath(selectedTile.row, selectedTile.col, hoveredTile.row, hoveredTile.col);\n    for (const tile of path) {\n        if (validMoveTiles.find(validTile => validTile.row === tile.y && validTile.col === tile.x)) {\n            drawPathTile(tile.y, tile.x);\n        }\n    }\n}\nfunction drawPathTile(row, col) {\n    const frameSize = 32;\n    const highlightFrameX = 0;\n    const highlightFrameY = 4;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawMoveTile(row, col) {\n    validMoveTiles.push({ row, col });\n    if (!selectedTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = 3;\n    const highlightFrameY = 1;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawActionTiles() {\n    if (isAction) {\n        if (moveTile) {\n            const unit = units.find(unit => unit.row === moveTile.row && unit.col === moveTile.col);\n            if (unit) {\n                validActionTiles = [];\n                const range = unit.range;\n                const row = moveTile.row;\n                const col = moveTile.col;\n                let actionPerformed = false;\n                for (let i = -range; i <= range; i++) {\n                    for (let j = -range; j <= range; j++) {\n                        if (Math.abs(i) + Math.abs(j) <= range) {\n                            if (i === 0 && j === 0)\n                                continue;\n                            if (!hasUnit(row + i, col + j))\n                                continue;\n                            let action = unit.action;\n                            if (action === 'heal' && !unitIsTeam(row + i, col + j))\n                                continue;\n                            if (action === 'heal' && !unitCanBeHealed(row + i, col + j))\n                                continue;\n                            if (action === 'attack' && !unitCanBeAttacked(row + i, col + j))\n                                continue;\n                            if (action === 'attack' && unitIsTeam(row + i, col + j))\n                                continue;\n                            drawActionTile(row + i, col + j, action);\n                            actionPerformed = true;\n                        }\n                    }\n                }\n                if (!actionPerformed) {\n                    unit.canAct = false;\n                    isAction = false;\n                    moveTile = null;\n                    window.socket.emit('force-unit-end-turn', unit.id);\n                }\n            }\n        }\n    }\n}\nfunction drawActionTile(row, col, action) {\n    validActionTiles.push({ row, col });\n    const frameSize = 32;\n    const highlightFrameX = action === 'attack' ? 2 : 1;\n    const highlightFrameY = 1;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\n// -----------Canvas Events Controls-----------------------\nwindow.addEventListener('keydown', (e) => {\n    switch (e.key) {\n        case 'z':\n            if (exports.SCALE !== MIN_SCALE)\n                exports.SCALE -= 0.125;\n            if (exports.SCALE < MIN_SCALE)\n                exports.SCALE = MIN_SCALE;\n            break;\n        case 'x':\n            if (exports.SCALE !== MAX_SCALE)\n                exports.SCALE += 0.125;\n            if (exports.SCALE > MAX_SCALE)\n                exports.SCALE = MAX_SCALE;\n            break;\n        case \"ArrowUp\":\n        case \"w\":\n            cameraOffsetY += 8 * exports.SCALE;\n            break;\n        case \"ArrowDown\":\n        case \"s\":\n            cameraOffsetY -= 8 * exports.SCALE;\n            break;\n        case \"ArrowLeft\":\n        case \"a\":\n            cameraOffsetX += 8 * exports.SCALE;\n            break;\n        case \"ArrowRight\":\n        case \"d\":\n            cameraOffsetX -= 8 * exports.SCALE;\n            break;\n        case \"Enter\":\n            window.socket.emit('force-end-turn');\n            selectedTile = null;\n            isAction = false;\n            moveTile = null;\n            break;\n    }\n});\nlet isDragging = false;\nlet startX = 0;\nlet startY = 0;\ncanvas.addEventListener('click', function (event) {\n    if (!isTurn())\n        return;\n    if (players.length != 2)\n        return;\n    const clickX = event.offsetX;\n    const clickY = event.offsetY;\n    let found = false;\n    for (const tile of tiles) {\n        if (!hoveredTile)\n            break;\n        if (helpers.isPointInsideTile(clickX, clickY, tile)) {\n            if (!isAction && !selectedTile && unitIsTeam(hoveredTile.row, hoveredTile.col) && unitCanMove(hoveredTile.row, hoveredTile.col)) {\n                // first click\n                selectedTile = tile;\n            }\n            else if (!isAction && selectedTile && tile.row === selectedTile.row && tile.col === selectedTile.col) {\n                // move clicked on the same tile to stay\n                const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                window.socket.emit('player-unit-move', unit.id, tile);\n                break;\n            }\n            else if (!isAction && selectedTile && unitIsTeam(selectedTile.row, selectedTile.col)) {\n                // move clicked on another tile to move\n                if (validMoveTiles.find(validTile => validTile.row === tile.row && validTile.col === tile.col)) {\n                    const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                    window.socket.emit('player-unit-move', unit.id, tile);\n                }\n                selectedTile = null;\n            }\n            else if (isAction && hasUnit(tile.row, tile.col)) {\n                // action clicked on another unit\n                if (validActionTiles.find(validTile => validTile.row === tile.row && validTile.col === tile.col)) {\n                    const unit = units.find(unit => unit.row === moveTile.row && unit.col === moveTile.col);\n                    window.socket.emit('player-unit-action', unit.id, tile);\n                }\n                isAction = false;\n                moveTile = null;\n            }\n            else if (isAction && hasUnit(tile.row, tile.col)) {\n                // action clicked on same tile to cancel\n                const unit = units.find(unit => unit.row === moveTile.row && unit.col === moveTile.col);\n                isAction = false;\n                moveTile = null;\n                window.socket.emit('player-unit-action', unit.id, tile);\n            }\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        selectedTile = null;\n    }\n});\ncanvas.addEventListener('mousedown', (e) => {\n    if (e.button !== 1)\n        return;\n    isDragging = true;\n    startX = e.clientX - cameraOffsetX;\n    startY = e.clientY - cameraOffsetY;\n});\ncanvas.addEventListener('mouseup', () => {\n    isDragging = false;\n});\ncanvas.addEventListener('mouseleave', () => {\n    isDragging = false;\n});\ncanvas.addEventListener('wheel', (e) => {\n    if (e.deltaY < 0) {\n        if (exports.SCALE !== MAX_SCALE)\n            exports.SCALE *= 1.1;\n        if (exports.SCALE > MAX_SCALE)\n            exports.SCALE = MAX_SCALE;\n    }\n    else if (e.deltaY > 0) {\n        if (exports.SCALE !== MIN_SCALE)\n            exports.SCALE *= 0.9;\n        if (exports.SCALE < MIN_SCALE)\n            exports.SCALE = MIN_SCALE;\n    }\n});\ncanvas.addEventListener('mousemove', function (event) {\n    const clickX = event.offsetX;\n    const clickY = event.offsetY;\n    for (const tile of tiles) {\n        if (helpers.isPointInsideTile(clickX, clickY, tile)) {\n            hoveredTile = tile;\n            break;\n        }\n        else {\n            hoveredTile = null;\n        }\n    }\n    if (isDragging) {\n        cameraOffsetX = event.clientX - startX;\n        cameraOffsetY = event.clientY - startY;\n    }\n});\n// -----------Touch Screen Logic---------------------------\nlet touchStartTime = 0;\nconst TAP_THRESHOLD = 200;\nlet prevTouchDistance = null;\ncanvas.addEventListener('touchstart', function (e) {\n    e.preventDefault(); // Prevent default touch behavior (like scrolling)\n    if (e.touches.length === 1) {\n        touchStartTime = Date.now();\n        // Single touch - start drag\n        isDragging = true;\n        startX = e.touches[0].clientX - cameraOffsetX;\n        startY = e.touches[0].clientY - cameraOffsetY;\n        const touch = e.changedTouches[0];\n        const clickX = touch.clientX - canvas.offsetLeft;\n        const clickY = touch.clientY - canvas.offsetTop;\n        let found = false;\n        for (const tile of tiles) {\n            if (!hoveredTile)\n                break;\n            if (helpers.isPointInsideTile(clickX, clickY, tile)) {\n                if (!selectedTile && unitIsTeam(hoveredTile.row, hoveredTile.col)) {\n                    selectedTile = tile;\n                }\n                else if (selectedTile && tile.row === selectedTile.row && tile.col === selectedTile.col) {\n                    const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                    window.socket.emit('player-unit-move', unit.id, tile);\n                    break;\n                }\n                else if (selectedTile && unitIsTeam(selectedTile.row, selectedTile.col)) {\n                    const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                    window.socket.emit('player-unit-move', unit.id, tile);\n                    selectedTile = null;\n                }\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            selectedTile = null;\n        }\n    }\n    else if (e.touches.length === 2) {\n        // Two touches - pinch-to-zoom\n        const touch1X = e.touches[0].clientX;\n        const touch1Y = e.touches[0].clientY;\n        const touch2X = e.touches[1].clientX;\n        const touch2Y = e.touches[1].clientY;\n        // Calculate the initial distance between the two touch points\n        prevTouchDistance = Math.sqrt((touch2X - touch1X) ** 2 + (touch2Y - touch1Y) ** 2);\n    }\n});\ncanvas.addEventListener('touchmove', function (e) {\n    e.preventDefault();\n    if (e.touches.length === 1) {\n        const touchX = e.touches[0].clientX;\n        const touchY = e.touches[0].clientY;\n        if (isDragging) {\n            cameraOffsetX = touchX - startX;\n            cameraOffsetY = touchY - startY;\n            // Update hovered tile (similar to mousemove)\n            const clickX = touchX - canvas.offsetLeft;\n            const clickY = touchY - canvas.offsetTop;\n            for (const tile of tiles) {\n                if (helpers.isPointInsideTile(clickX, clickY, tile)) {\n                    hoveredTile = tile;\n                    break;\n                }\n                else {\n                    hoveredTile = null;\n                }\n            }\n        }\n        // Check if the movement is enough to start a drag (move threshold)\n        const movementThreshold = 5; // Pixels of movement threshold before considering it a drag\n        const moved = Math.abs(touchX - startX) > movementThreshold || Math.abs(touchY - startY) > movementThreshold;\n        if (moved) {\n            isDragging = true;\n        }\n    }\n    if (e.touches.length === 2) {\n        // Two touches - pinch-to-zoom\n        const touch1X = e.touches[0].clientX;\n        const touch1Y = e.touches[0].clientY;\n        const touch2X = e.touches[1].clientX;\n        const touch2Y = e.touches[1].clientY;\n        // Calculate the current distance between the two touch points\n        const currentDistance = Math.sqrt((touch2X - touch1X) ** 2 + (touch2Y - touch1Y) ** 2);\n        if (prevTouchDistance !== null) {\n            // Calculate the scale factor based on the distance change\n            const scaleChange = currentDistance / prevTouchDistance;\n            // Apply the zoom (scale) adjustment\n            if (scaleChange > 1) {\n                // Zoom in (scale up)\n                if (exports.SCALE !== MAX_SCALE)\n                    exports.SCALE *= 1.05;\n                if (exports.SCALE > MAX_SCALE)\n                    exports.SCALE = MAX_SCALE;\n            }\n            else {\n                // Zoom out (scale down)\n                if (exports.SCALE !== MIN_SCALE)\n                    exports.SCALE *= 0.95;\n                if (exports.SCALE < MIN_SCALE)\n                    exports.SCALE = MIN_SCALE;\n            }\n        }\n        // Update the previous touch distance for the next move event\n        prevTouchDistance = currentDistance;\n    }\n});\ncanvas.addEventListener('touchend', function (e) {\n    const touchEndTime = Date.now();\n    const touchDuration = touchEndTime - touchStartTime;\n    if (e.touches.length === 0 && touchDuration < TAP_THRESHOLD) {\n        // This was a tap (short touch duration and no dragging)\n        const touch = e.changedTouches[0];\n        const clickX = touch.clientX - canvas.offsetLeft;\n        const clickY = touch.clientY - canvas.offsetTop;\n        let found = false;\n        for (const tile of tiles) {\n            if (!hoveredTile)\n                continue;\n            if (helpers.isPointInsideTile(clickX, clickY, tile)) {\n                if (!selectedTile && unitIsTeam(hoveredTile.row, hoveredTile.col)) {\n                    selectedTile = tile;\n                }\n                else if (selectedTile && tile.row === selectedTile.row && tile.col === selectedTile.col) {\n                    const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                    window.socket.emit('player-unit-move', unit.id, tile);\n                    break;\n                }\n                else if (selectedTile && unitIsTeam(selectedTile.row, selectedTile.col)) {\n                    const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                    window.socket.emit('player-unit-move', unit.id, tile);\n                    selectedTile = null;\n                }\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            selectedTile = null;\n        }\n    }\n    isDragging = false;\n    if (e.touches.length < 2) {\n        prevTouchDistance = null;\n    }\n});\n// ---------------UI EVENTS--------------------------------------------------------\nendTurnBtn.addEventListener('click', function (e) {\n    window.socket.emit('force-end-turn');\n    selectedTile = null;\n    isAction = false;\n    moveTile = null;\n});\n// ----------------Helpers=========================================================\nfunction formatTime(seconds) {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    const formattedMinutes = minutes.toString().padStart(2, '0');\n    const formattedSeconds = remainingSeconds.toString().padStart(2, '0');\n    return `${formattedMinutes}:${formattedSeconds}`;\n}\nfunction unitCanMove(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return unit.canMove;\n        }\n    }\n    return false;\n}\nfunction hasUnit(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction unitIsTeam(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return unit.owner.socket === window.socket.id;\n        }\n    }\n    return false;\n}\nfunction unitCanBeHealed(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            if (unit.owner.socket !== window.socket.id)\n                return false;\n            return unit.health < unit.maxHealth;\n        }\n    }\n    return false;\n}\nfunction unitCanBeAttacked(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            if (unit.owner.socket === window.socket.id)\n                return false;\n            return unit.health > 0;\n        }\n    }\n    return false;\n}\nfunction isVisibleTile(row, col) {\n    const tile = visibleTiles.find(visibleTiles => visibleTiles.row === row && visibleTiles.col === col);\n    if (tile)\n        return true;\n    return false;\n}\nfunction adjacentTile(row1, col1, row2, col2) {\n    return (row1 === row2 && col1 === col2) ||\n        (Math.abs(row1 - row2) === 1 && col1 === col2) ||\n        (Math.abs(col1 - col2) === 1 && row1 === row2);\n}\n// A* Pathfinding Algorithm\n// TODO: take into account tile movement weight\nfunction astarPath(startRow, startCol, endRow, endCol) {\n    if (!arena)\n        return [];\n    const grid = arena.tiles;\n    const openList = [];\n    const closedList = new Set();\n    const startTile = {\n        x: startCol,\n        y: startRow,\n        g: 0,\n        h: heuristic({ x: startCol, y: startRow, g: 0, h: 0, f: 0, parent: null }, { x: endCol, y: endRow, g: 0, h: 0, f: 0, parent: null }),\n        f: 0,\n        parent: null\n    };\n    const endTile = { x: endCol, y: endRow, g: 0, h: 0, f: 0, parent: null };\n    openList.push(startTile);\n    const neighbors = [\n        { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },\n    ];\n    while (openList.length > 0) {\n        // Sort openList by F cost (lowest F cost first)\n        openList.sort((a, b) => a.f - b.f);\n        const current = openList.shift(); // Get the tile with the lowest F cost\n        // If we've reached the goal, reconstruct the path\n        if (current.x === endTile.x && current.y === endTile.y) {\n            const path = [];\n            let currentTile = current;\n            while (currentTile) {\n                path.unshift({ x: currentTile.x, y: currentTile.y });\n                currentTile = currentTile.parent;\n            }\n            return path;\n        }\n        closedList.add(`${current.x},${current.y}`);\n        // Check all neighbors\n        for (const { x: dx, y: dy } of neighbors) {\n            const neighborX = current.x + dx;\n            const neighborY = current.y + dy;\n            // Check if the neighbor is within bounds and is not an obstacle (assuming 1 = walkable, 0 = obstacle) and height difference is not >= 1.5\n            if (neighborX >= 0 && neighborX < grid[0].length && neighborY >= 0 && neighborY < grid.length && (grid[neighborY][neighborX] !== 0 && grid[neighborY][neighborX] !== 4) && arena.heightMap[neighborY][neighborX] - arena.heightMap[current.y][current.x] <= 1.5) {\n                const neighbor = {\n                    x: neighborX,\n                    y: neighborY,\n                    g: current.g + 1, // Assume cost to move to any neighbor is 1\n                    h: heuristic({ x: neighborX, y: neighborY, g: 0, h: 0, f: 0, parent: null }, { x: endCol, y: endRow, g: 0, h: 0, f: 0, parent: null }),\n                    f: 0,\n                    parent: current\n                };\n                if (closedList.has(`${neighbor.x},${neighbor.y}`)) {\n                    continue; // Skip if already evaluated\n                }\n                // Check if this neighbor is better (lower f) than any previously evaluated\n                if (!openList.some(tile => tile.x === neighbor.x && tile.y === neighbor.y)) {\n                    neighbor.f = neighbor.g + neighbor.h;\n                    openList.push(neighbor);\n                }\n            }\n        }\n    }\n    return []; // No path found\n}\nfunction heuristic(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n// Bresenham's Line Algorithm\nfunction bresenhamPath(startRow, startCol, endRow, endCol) {\n    const path = [];\n    let x = startCol;\n    let y = startRow;\n    const dx = Math.abs(endCol - startCol);\n    const dy = Math.abs(endRow - startRow);\n    const sx = startCol < endCol ? 1 : -1;\n    const sy = startRow < endRow ? 1 : -1;\n    let err = dx - dy;\n    while (x !== endCol || y !== endRow) {\n        path.push({ x, y });\n        const e2 = err * 2;\n        if (e2 > -dy) {\n            err -= dy;\n            x += sx;\n        }\n        if (e2 < dx) {\n            err += dx;\n            y += sy;\n        }\n    }\n    path.push({ y: endRow, x: endCol });\n    return path;\n}\nfunction coordToPosition(row, col) {\n    for (const tile of tiles) {\n        if (tile.row === row && tile.col === col) {\n            return { x: tile.x, y: tile.y };\n        }\n    }\n    return { x: -9999, y: -9999 };\n}\nfunction isTurn() {\n    return players[currentRound % 2].socket === window.socket.id;\n}\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction getTileHeight(row, col) {\n    if (!arena)\n        return 0;\n    return arena.heightMap[row][col] - 1;\n}\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/game.ts?");

/***/ }),

/***/ "./src/client/helpers.ts":
/*!*******************************!*\
  !*** ./src/client/helpers.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPointInsideTile = isPointInsideTile;\nconst game_1 = __webpack_require__(/*! ./game */ \"./src/client/game.ts\");\nfunction isPointInsideTile(px, py, tile) {\n    // Vertices of the tile\n    const x1 = tile.x, y1 = tile.y;\n    const x2 = tile.x + 16 * game_1.SCALE, y2 = tile.y + 8 * game_1.SCALE;\n    const x3 = tile.x + 32 * game_1.SCALE, y3 = tile.y;\n    const x4 = tile.x + 16 * game_1.SCALE, y4 = tile.y - 8 * game_1.SCALE;\n    // Helper function to calculate the area of a triangle given by three points\n    const sign = (x1, y1, x2, y2, x3, y3) => {\n        return (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);\n    };\n    // Check if the point is inside the tile (diamond shape)\n    const d1 = sign(px, py, x1, y1, x2, y2);\n    const d2 = sign(px, py, x2, y2, x3, y3);\n    const d3 = sign(px, py, x3, y3, x4, y4);\n    const d4 = sign(px, py, x4, y4, x1, y1);\n    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0) || (d4 < 0);\n    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0) || (d4 > 0);\n    // Point is inside the tile if all signs are the same (either all positive or all negative)\n    return !(hasNeg && hasPos);\n}\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/helpers.ts?");

/***/ }),

/***/ "./src/client/sprites.ts":
/*!*******************************!*\
  !*** ./src/client/sprites.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sprites = void 0;\nclass SpriteClass {\n    constructor(height, width, name, image, idleFrames, currentFrame, framesElapsed, framesHold) {\n        this.height = height;\n        this.width = width;\n        this.name = name;\n        this.image = image;\n        this.idleFrames = idleFrames;\n        this.currentFrame = currentFrame;\n        this.framesElapsed = framesElapsed;\n        this.framesHold = framesHold;\n    }\n    copy() {\n        return new SpriteClass(this.height, this.width, this.name, this.image, this.idleFrames, this.currentFrame, this.framesElapsed, this.framesHold);\n    }\n}\nexports.sprites = [\n    new SpriteClass(32, 32, \"test\", \"test\", 2, 0, 0, 100),\n];\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/sprites.ts?");

/***/ }),

/***/ "./src/client/tiles.ts":
/*!*****************************!*\
  !*** ./src/client/tiles.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tileTypes = void 0;\nexports.tileTypes = [\n    { id: 0, name: 'VOID', movement: 0 },\n    { id: 1, name: 'GROUND', movement: 1 },\n    { id: 2, name: 'SLOW', movement: 2 },\n    { id: 3, name: 'HIDING SPOT', movement: 1 },\n    { id: 4, name: 'OBSTACLE', movement: 0 },\n];\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/tiles.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/client/game.ts");
/******/ 	
/******/ })()
;