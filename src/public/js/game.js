/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client/game.ts":
/*!****************************!*\
  !*** ./src/client/game.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SCALE = void 0;\nconst helpers = __importStar(__webpack_require__(/*! ./helpers */ \"./src/client/helpers.ts\"));\nconst sprites_1 = __webpack_require__(/*! ./sprites */ \"./src/client/sprites.ts\");\nconst MIN_SCALE = 1.0;\nconst MAX_SCALE = 5.0;\nexports.SCALE = 3.125;\nlet cameraOffsetX = 0;\nlet cameraOffsetY = 75;\nlet arenaImage = null;\nlet arena = null;\nconst tileTypes = [\n    { id: 1, name: 'PLAINS', movement: 1 },\n    { id: 2, name: 'HILLS', movement: 2 },\n    { id: 3, name: 'FOREST', movement: 1 },\n    { id: 4, name: 'WALL', movement: 0 },\n];\nlet uiImage = new Image();\nuiImage.src = '/assets/spritesheets/UI.png';\nlet players = [];\nlet units = [];\nlet visibleTiles = [];\nlet hoveredTile = null;\nlet selectedTile = null;\nlet moveTile = null;\nlet validMoveTiles = [];\nlet actionTile = null;\nlet validActionTiles = [];\nlet currentRound = 0;\nlet player1Time = 0;\nlet player2Time = 0;\nlet isAction = false;\nconst endTurnBtn = document.getElementById('endTurnBtn');\nconst gameOverUI = document.getElementById('gameOver');\nlet gameOver = false;\nconst canvas = document.getElementById('gameCanvas');\nconst ctx = canvas.getContext('2d');\nfunction drawBackground() {\n    ctx.fillStyle = '#222034';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n}\nfunction drawArena() {\n    if (arenaImage) {\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(arenaImage, (canvas.width - arena.width * exports.SCALE) / 2 + cameraOffsetX, (canvas.height - arena.height * exports.SCALE + 16 * exports.SCALE) / 2 + cameraOffsetY, arena.width * exports.SCALE, arena.height * exports.SCALE);\n    }\n}\nfunction draw() {\n    if (!gameOver)\n        gameOverUI.style.display = 'none';\n    else\n        gameOverUI.style.display = 'flex';\n    const loading = document.getElementById('loading');\n    if (loading && players.length === 2)\n        loading.style.display = 'none';\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    drawBackground();\n    drawArena();\n    drawFogOfWarTiles();\n    drawUnits();\n    drawUI();\n    drawInteractionSquares();\n    editHTML();\n}\nfunction formatTime(seconds) {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    const formattedMinutes = minutes.toString().padStart(2, '0');\n    const formattedSeconds = remainingSeconds.toString().padStart(2, '0');\n    return `${formattedMinutes}:${formattedSeconds}`;\n}\nfunction editHTML() {\n    if (players.length < 2)\n        return;\n    const player1Name = document.getElementById('player1Name');\n    const player2Name = document.getElementById('player2Name');\n    player1Name.innerHTML = players[0].name;\n    player2Name.innerHTML = players[1].name;\n    const player1ProfilePic = document.getElementById('player1ProfilePic');\n    const player2ProfilePic = document.getElementById('player2ProfilePic');\n    player1ProfilePic.src = `/assets/profileimages/${players[0].profileimage}.png`;\n    player2ProfilePic.src = `/assets/profileimages/${players[1].profileimage}.png`;\n    const player1Timer = document.getElementById('player1Time');\n    const player2Timer = document.getElementById('player2Time');\n    const player1FormattedTime = formatTime(player1Time);\n    const player2FormattedTime = formatTime(player2Time);\n    player1Timer.innerHTML = player1FormattedTime;\n    player2Timer.innerHTML = player2FormattedTime;\n}\nwindow.addEventListener('keydown', (e) => {\n    switch (e.key) {\n        case 'z':\n            if (exports.SCALE !== MIN_SCALE)\n                exports.SCALE -= 0.125;\n            if (exports.SCALE < MIN_SCALE)\n                exports.SCALE = MIN_SCALE;\n            break;\n        case 'x':\n            if (exports.SCALE !== MAX_SCALE)\n                exports.SCALE += 0.125;\n            if (exports.SCALE > MAX_SCALE)\n                exports.SCALE = MAX_SCALE;\n            break;\n        case \"ArrowUp\":\n        case \"w\":\n            cameraOffsetY += 8 * exports.SCALE;\n            break;\n        case \"ArrowDown\":\n        case \"s\":\n            cameraOffsetY -= 8 * exports.SCALE;\n            break;\n        case \"ArrowLeft\":\n        case \"a\":\n            cameraOffsetX += 8 * exports.SCALE;\n            break;\n        case \"ArrowRight\":\n        case \"d\":\n            cameraOffsetX -= 8 * exports.SCALE;\n            break;\n        case \"Enter\":\n            window.socket.emit('force-end-turn');\n            selectedTile = null;\n            isAction = false;\n            moveTile = null;\n            break;\n    }\n});\nfunction loadUnits(players) {\n    if (!isAnimating) {\n        units = [];\n        for (const player of players) {\n            for (const unit of player.units) {\n                unit.owner = player;\n                unit.sprite = sprites_1.sprites.find(sprite => sprite.name === unit.name) || sprites_1.sprites[0];\n                unit.currentStatus = unit.canMove || unit.canAct ? 0 : 1;\n                units.push(unit);\n            }\n        }\n    }\n    else {\n        if (!animatingUnit)\n            return;\n        units = [];\n        units.push(animatingUnit);\n        for (const player of players) {\n            for (const unit of player.units) {\n                if (unit.id === animatingUnit.id)\n                    continue;\n                unit.owner = player;\n                unit.sprite = sprites_1.sprites.find(sprite => sprite.name === unit.name) || sprites_1.sprites[0];\n                unit.currentStatus = unit.canMove || unit.canAct ? 0 : 1;\n                units.push(unit);\n            }\n        }\n    }\n}\nfunction loadPlayers(newPlayers) {\n    players = [];\n    players = newPlayers;\n    if (players.length === 2) {\n        if (isTurn())\n            endTurnBtn.disabled = false;\n        else\n            endTurnBtn.disabled = true;\n    }\n}\nwindow.socket.on('gameState', (gameState) => {\n    loadArenaImage(gameState.arena); // move to a game start function in the future to only load once\n    loadPlayers(gameState.players);\n    loadUnits(gameState.players);\n    visibleTiles = gameState.visibleTiles;\n    currentRound = gameState.round;\n    player1Time = gameState.player1Time;\n    player2Time = gameState.player2Time;\n});\nwindow.socket.on('gameOver', (player) => {\n    const gameOverMsg = document.getElementById('gameOverMsg');\n    if (!gameOverMsg)\n        return;\n    if (player.socket !== window.socket.id) {\n        gameOverMsg.innerHTML = \"YOU LOSE...\";\n    }\n    else {\n        gameOverMsg.innerHTML = \"YOU WIN!\";\n    }\n    gameOver = true;\n});\nwindow.socket.on('nextRound', (player) => {\n    const nextRoundMsg = document.getElementById('nextRoundMsg');\n    if (!nextRoundMsg)\n        return;\n    const nextTurnBG = document.getElementById('nextTurnBG');\n    if (!nextTurnBG)\n        return;\n    if (player.socket !== window.socket.id) {\n        nextRoundMsg.innerHTML = \"ENEMY TURN\";\n        nextTurnBG.classList.add(\"border-red-500\");\n        nextTurnBG.classList.remove(\"border-blue-500\");\n    }\n    else {\n        nextRoundMsg.innerHTML = \"YOUR TURN\";\n        nextTurnBG.classList.add(\"border-blue-500\");\n        nextTurnBG.classList.remove(\"border-red-500\");\n    }\n    const nextTurnDiv = document.getElementById(\"nextTurn\");\n    nextTurnDiv.classList.toggle(\"top-full\");\n    nextTurnDiv.classList.toggle(\"top-0\");\n    setTimeout(() => {\n        nextTurnDiv.classList.toggle(\"top-full\");\n        nextTurnDiv.classList.toggle(\"top-0\");\n    }, 4000);\n});\nfunction gameLoop() {\n    draw();\n    requestAnimationFrame(gameLoop);\n}\ngameLoop();\nfunction loadArenaImage(newArena) {\n    if (!arenaImage) {\n        arenaImage = new Image();\n        arenaImage.src = `/assets/maps/${newArena.name}.png`;\n        arena = newArena;\n        arenaImage.onload = () => {\n            drawArena();\n        };\n    }\n}\nfunction resizeCanvas() {\n    canvas.width = window.outerWidth;\n    canvas.height = window.innerHeight;\n    draw();\n}\nresizeCanvas();\nwindow.addEventListener('resize', resizeCanvas);\nwindow.addEventListener('orientationchange', resizeCanvas);\nlet tiles = [];\nfunction drawInteractionSquares() {\n    if (!arenaImage)\n        return;\n    if (!arena)\n        return;\n    const tileWidth = 32 * exports.SCALE; // width of an isometric tile\n    const tileHeight = 16 * exports.SCALE; // height of an isometric tile\n    const rows = arena.tiles.length;\n    const cols = arena.tiles[0].length;\n    // get canvas center\n    const imgCenterX = canvas.width / 2;\n    const imgCenterY = canvas.height / 2;\n    // Calculate the total width and height of the grid\n    const gridWidth = (cols - 1) * tileWidth / 2; // Total width of the grid\n    const gridHeight = (rows - 1) * tileHeight / 2; // Total height of the grid\n    // Calculate the offset to center the grid on the image\n    const offsetX = imgCenterX - tileWidth / 2 + cameraOffsetX;\n    const offsetY = imgCenterY - gridHeight - tileHeight - 8 * exports.SCALE + cameraOffsetY;\n    // Draw the tiles\n    tiles = [];\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            // Calculate isometric coordinates\n            if (arena.tiles[row][col] === 0)\n                continue;\n            const isoX = (col - row) * tileWidth / 2 + offsetX;\n            const isoY = (col + row) * tileHeight / 2 + offsetY;\n            tiles.push(drawIsometricTile(isoX, isoY, row, col));\n        }\n    }\n}\nfunction drawIsometricTile(x, y, row, col) {\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + 16 * exports.SCALE, y + 8 * exports.SCALE);\n    ctx.lineTo(x + 32 * exports.SCALE, y);\n    ctx.lineTo(x + 16 * exports.SCALE, y - 8 * exports.SCALE);\n    ctx.closePath();\n    //ctx.stroke();\n    return { x, y, row, col };\n}\nwindow.socket.on('player-unit-moving', (unit, origin, target) => {\n    isAction = true;\n    animateMove(unit, origin, target);\n    moveTile = target;\n    console.log(`Unit ${unit.id} looking to perform an action`);\n});\nlet isAnimating = false;\nlet animatingUnit;\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction animateMove(tempUnit, origin, target) {\n    return __awaiter(this, void 0, void 0, function* () {\n        isAnimating = true;\n        const path = astarPath(origin.row, origin.col, target.row, target.col);\n        const realUnit = units.find(unit => unit.row === tempUnit.row && unit.col === tempUnit.col);\n        if (!realUnit)\n            return;\n        for (const tile of path) {\n            if (!isAnimating)\n                break;\n            animatingUnit = realUnit;\n            realUnit.currentStatus = 2;\n            realUnit.sprite.currentFrame = 0;\n            // play footstep sound\n            realUnit.row = tile.y;\n            realUnit.col = tile.x;\n            yield sleep(100);\n        }\n        isAnimating = false;\n        animatingUnit = null;\n        realUnit.currentStatus = 0;\n        realUnit.sprite.currentFrame = 0;\n    });\n}\nfunction isTurn() {\n    return players[currentRound % 2].socket === window.socket.id;\n}\nfunction unitCanMove(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return unit.canMove;\n        }\n    }\n    return false;\n}\nlet isDragging = false;\nlet startX = 0;\nlet startY = 0;\ncanvas.addEventListener('click', function (event) {\n    if (isAnimating)\n        isAnimating = false;\n    if (!isTurn())\n        return;\n    if (players.length != 2)\n        return;\n    const clickX = event.offsetX;\n    const clickY = event.offsetY;\n    let found = false;\n    for (const tile of tiles) {\n        if (!hoveredTile)\n            break;\n        if (helpers.isPointInsideTile(clickX, clickY, tile)) {\n            if (!isAction && !selectedTile && unitIsTeam(hoveredTile.row, hoveredTile.col) && unitCanMove(hoveredTile.row, hoveredTile.col)) {\n                // first click\n                selectedTile = tile;\n            }\n            else if (!isAction && selectedTile && tile.row === selectedTile.row && tile.col === selectedTile.col) {\n                // move clicked on the same tile to stay\n                const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                console.log(`Staying on: ${tile.row}, ${tile.col}`);\n                window.socket.emit('player-unit-move', unit.id, tile);\n                break;\n            }\n            else if (!isAction && selectedTile && unitIsTeam(selectedTile.row, selectedTile.col)) {\n                // move clicked on another tile to move\n                if (validMoveTiles.find(validTile => validTile.row === tile.row && validTile.col === tile.col)) {\n                    const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n                    console.log(`Moving to: ${tile.row}, ${tile.col}`);\n                    window.socket.emit('player-unit-move', unit.id, tile);\n                }\n                selectedTile = null;\n            }\n            else if (isAction && hasUnit(tile.row, tile.col)) {\n                // action clicked on another unit\n                if (validActionTiles.find(validTile => validTile.row === tile.row && validTile.col === tile.col)) {\n                    const unit = units.find(unit => unit.row === moveTile.row && unit.col === moveTile.col);\n                    console.log(`Action on: ${tile.row}, ${tile.col}`);\n                    window.socket.emit('player-unit-action', unit.id, tile);\n                }\n                isAction = false;\n                moveTile = null;\n            }\n            else if (isAction && hasUnit(tile.row, tile.col)) {\n                // action clicked on same tile to cancel\n                const unit = units.find(unit => unit.row === moveTile.row && unit.col === moveTile.col);\n                isAction = false;\n                moveTile = null;\n                console.log(`Cancel action on: ${tile.row}, ${tile.col}`);\n                window.socket.emit('player-unit-action', unit.id, tile);\n            }\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        selectedTile = null;\n    }\n});\ncanvas.addEventListener('mousedown', (e) => {\n    if (e.button !== 1)\n        return;\n    isDragging = true;\n    startX = e.clientX - cameraOffsetX;\n    startY = e.clientY - cameraOffsetY;\n});\ncanvas.addEventListener('mouseup', () => {\n    isDragging = false;\n});\ncanvas.addEventListener('mouseleave', () => {\n    isDragging = false;\n});\ncanvas.addEventListener('wheel', (e) => {\n    if (e.deltaY < 0) {\n        if (exports.SCALE !== MAX_SCALE)\n            exports.SCALE *= 1.1;\n        if (exports.SCALE > MAX_SCALE)\n            exports.SCALE = MAX_SCALE;\n    }\n    else if (e.deltaY > 0) {\n        if (exports.SCALE !== MIN_SCALE)\n            exports.SCALE *= 0.9;\n        if (exports.SCALE < MIN_SCALE)\n            exports.SCALE = MIN_SCALE;\n    }\n});\ncanvas.addEventListener('mousemove', function (event) {\n    const clickX = event.offsetX;\n    const clickY = event.offsetY;\n    for (const tile of tiles) {\n        if (helpers.isPointInsideTile(clickX, clickY, tile)) {\n            //console.log(`You hovered on: ${tile.row}, ${tile.col}`);\n            hoveredTile = tile;\n            break;\n        }\n        else {\n            hoveredTile = null;\n        }\n    }\n    if (isDragging) {\n        cameraOffsetX = event.clientX - startX;\n        cameraOffsetY = event.clientY - startY;\n    }\n});\nfunction hasUnit(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction unitIsTeam(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return unit.owner.socket === window.socket.id;\n        }\n    }\n    return false;\n}\nfunction unitCanBeHealed(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            if (unit.owner.socket !== window.socket.id)\n                return false;\n            return unit.health < unit.maxHealth;\n        }\n    }\n    return false;\n}\nfunction unitCanBeAttacked(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            if (unit.owner.socket === window.socket.id)\n                return false;\n            return unit.health > 0;\n        }\n    }\n    return false;\n}\nfunction drawHoveredTile() {\n    if (!hoveredTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = hasUnit(hoveredTile.row, hoveredTile.col) ? (unitIsTeam(hoveredTile.row, hoveredTile.col) ? 1 : 2) : 0;\n    const highlightFrameY = 0;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, hoveredTile.x, hoveredTile.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawSelectedTile() {\n    if (!selectedTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = 3;\n    const highlightFrameY = 0;\n    const col = selectedTile.col;\n    const row = selectedTile.row;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawUI() {\n    drawHoveredTile();\n    drawSelectedTile();\n    drawMovementTiles();\n    drawActionTiles();\n    drawPath();\n    drawHealthBars();\n    drawTileInfo();\n    drawHoveredUnitName();\n}\nfunction drawTileInfo() {\n    if (!arena)\n        return;\n    if (!hoveredTile)\n        return;\n    const bgWidth = 256;\n    const bgHeight = 64;\n    const margin = 10;\n    const padding = 10;\n    const squareX = 0;\n    const squareY = margin;\n    const terrain = arena.tiles[hoveredTile.row][hoveredTile.col];\n    const terrainType = tileTypes.find(tile => tile.id === terrain);\n    if (!terrainType)\n        return;\n    ctx.fillStyle = '#45283c';\n    ctx.fillRect(squareX, squareY, bgWidth, bgHeight); // replace with tile info ui back image\n    ctx.fillStyle = 'white';\n    ctx.font = '24px \"Press Start 2P\"';\n    ctx.fillText(terrainType.name, squareX + padding, squareY + padding + 34);\n}\nfunction drawHoveredUnitName() {\n    if (!arena)\n        return;\n    if (!hoveredTile)\n        return;\n    if (!hasUnit(hoveredTile.row, hoveredTile.col))\n        return;\n    const bgHeight = 64;\n    const margin = 10;\n    const padding = 10;\n    const squareX = 0;\n    const squareY = canvas.height - bgHeight - margin - (64 * 4);\n    const hoveredUnit = units.find(unit => unit.row === hoveredTile.row && unit.col === hoveredTile.col);\n    if (!hoveredUnit)\n        return;\n    const bgWidth = hoveredUnit.name.length * 24 + 6 * padding;\n    ctx.fillStyle = '#45283c';\n    ctx.fillRect(squareX, squareY, bgWidth, bgHeight); // replace with tile info ui back image\n    ctx.fillStyle = 'white';\n    ctx.font = '24px \"Press Start 2P\"';\n    ctx.fillText(hoveredUnit.name.toUpperCase(), squareX + padding, squareY + padding + 34);\n}\nfunction drawFogOfWarTiles() {\n    if (!arena)\n        return;\n    for (let row = 0; row < arena.tiles.length; row++) {\n        for (let col = 0; col < arena.tiles[row].length; col++) {\n            if (arena.tiles[row][col] === 0)\n                continue;\n            if (isVisibleTile(row, col))\n                continue;\n            drawFogOfWarTile(row, col);\n        }\n    }\n}\nfunction isVisibleTile(row, col) {\n    const tile = visibleTiles.find(visibleTiles => visibleTiles.row === row && visibleTiles.col === col);\n    if (tile)\n        return true;\n    return false;\n}\nfunction drawFogOfWarTile(row, col) {\n    const frameSize = 32;\n    const highlightFrameX = 4;\n    const highlightFrameY = 1;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawHealthBars() {\n    for (const unit of units) {\n        const pos = coordToPosition(unit.row, unit.col);\n        if (pos.x === -9999 || pos.y === -9999)\n            return;\n        const frameSize = 16;\n        const frameX = unitIsTeam(unit.row, unit.col) ? 2 : 4;\n        const frameY = 4;\n        const sx = frameX * frameSize;\n        const sy = frameY * frameSize;\n        let gap = 1 * exports.SCALE;\n        let totalWidth = unit.maxHealth * (frameSize * exports.SCALE / 4) + (unit.maxHealth - 1) * gap;\n        let startX = pos.x - totalWidth / 2;\n        for (let i = 0; i < unit.maxHealth; i++) {\n            let xPosition = startX + i * (frameSize * exports.SCALE / 4 + gap) + frameSize * exports.SCALE;\n            if (i < unit.health) {\n                ctx.imageSmoothingEnabled = false;\n                ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, xPosition, pos.y - 28 * exports.SCALE, frameSize * exports.SCALE / 4, frameSize * exports.SCALE / 4);\n            }\n            else {\n                ctx.imageSmoothingEnabled = false;\n                ctx.drawImage(uiImage, sx + frameSize, sy, frameSize, frameSize, xPosition, pos.y - 28 * exports.SCALE, frameSize * exports.SCALE / 4, frameSize * exports.SCALE / 4);\n            }\n        }\n    }\n}\nfunction drawMovementTiles() {\n    if (!arena)\n        return;\n    if (selectedTile) {\n        const unit = units.find(unit => unit.row === selectedTile.row && unit.col === selectedTile.col);\n        if (unit) {\n            validMoveTiles = [];\n            const mobility = unit.mobility;\n            const range = unit.range;\n            const row = selectedTile.row;\n            const col = selectedTile.col;\n            let mobilityTiles = [];\n            for (let i = -mobility; i <= mobility; i++) {\n                for (let j = -mobility; j <= mobility; j++) {\n                    if (Math.abs(i) + Math.abs(j) <= mobility) {\n                        const targetRow = row + i;\n                        const targetCol = col + j;\n                        if (targetRow < 0 || targetCol < 0 || targetRow >= arena.tiles.length || targetCol >= arena.tiles[0].length)\n                            continue;\n                        if (hasUnit(targetRow, targetCol) && (i !== 0 || j !== 0))\n                            continue;\n                        const targetTerrain = arena.tiles[targetRow][targetCol];\n                        if (targetTerrain === 0)\n                            continue;\n                        // Check the path for obstacles or terrain that blocks movement\n                        const path = astarPath(row, col, targetRow, targetCol);\n                        if (path.length - 1 > mobility)\n                            continue;\n                        let canMove = true;\n                        let mobilityPenalty = 0;\n                        for (const tile of path) {\n                            const terrain = arena.tiles[tile.y][tile.x];\n                            if ((row !== tile.y && col !== tile.x) && hasUnit(tile.y, tile.x)) {\n                                canMove = false;\n                                break;\n                            }\n                            else if (terrain === 0) {\n                                canMove = false;\n                                break;\n                            }\n                            else if (terrain === 2) {\n                                mobilityPenalty += 2;\n                            }\n                            else if (terrain === 3) {\n                            }\n                            else if (terrain === 4) {\n                                canMove = false;\n                                break;\n                            }\n                        }\n                        if (canMove && (mobility - mobilityPenalty >= 0)) {\n                            mobilityTiles.push({ x: targetRow, y: targetCol });\n                            drawMoveTile(targetRow, targetCol);\n                        }\n                    }\n                }\n            }\n            //Second loop: Draw attack range borders\n            for (let tile of mobilityTiles) {\n                const mobilityTileRow = tile.x;\n                const mobilityTileCol = tile.y;\n                for (let i = -range; i <= range; i++) {\n                    for (let j = -range; j <= range; j++) {\n                        if (Math.abs(i) + Math.abs(j) <= range) {\n                            let action = unit.action;\n                            const targetRow = mobilityTileRow + i;\n                            const targetCol = mobilityTileCol + j;\n                            if (targetRow === row && targetCol === col)\n                                continue;\n                            if (mobilityTiles.find(tile => tile.x === targetRow && tile.y === targetCol))\n                                continue;\n                            if (hasUnit(targetRow, targetCol))\n                                continue;\n                            if (targetRow >= 0 && targetRow < arena.tiles.length && targetCol >= 0 && targetCol < arena.tiles[0].length) {\n                                // Check the path for tiles that can restrict visibility\n                                const path = bresenhamPath(mobilityTileRow, mobilityTileCol, targetRow, targetCol);\n                                let canSee = true;\n                                let rangePenalty = 0;\n                                for (const tile of path) {\n                                    if (arena.tiles) {\n                                        const terrain = arena.tiles[tile.y][tile.x];\n                                        if (terrain === 3) {\n                                            if (!adjacentTile(row, col, tile.y, tile.x)) {\n                                                canSee = false;\n                                                break;\n                                            }\n                                        }\n                                        if (terrain === 4) {\n                                            canSee = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (canSee && (range - rangePenalty >= 0)) {\n                                    drawActionTile(targetRow, targetCol, action);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nfunction adjacentTile(row1, col1, row2, col2) {\n    return (row1 === row2 && col1 === col2) ||\n        (Math.abs(row1 - row2) === 1 && col1 === col2) ||\n        (Math.abs(col1 - col2) === 1 && row1 === row2);\n}\n// A* Pathfinding Algorithm\nfunction astarPath(startRow, startCol, endRow, endCol) {\n    if (!arena)\n        return [];\n    const grid = arena.tiles;\n    const openList = [];\n    const closedList = new Set();\n    const startTile = {\n        x: startCol,\n        y: startRow,\n        g: 0,\n        h: heuristic({ x: startCol, y: startRow, g: 0, h: 0, f: 0, parent: null }, { x: endCol, y: endRow, g: 0, h: 0, f: 0, parent: null }),\n        f: 0,\n        parent: null\n    };\n    const endTile = { x: endCol, y: endRow, g: 0, h: 0, f: 0, parent: null };\n    openList.push(startTile);\n    const neighbors = [\n        { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },\n    ];\n    while (openList.length > 0) {\n        // Sort openList by F cost (lowest F cost first)\n        openList.sort((a, b) => a.f - b.f);\n        const current = openList.shift(); // Get the tile with the lowest F cost\n        // If we've reached the goal, reconstruct the path\n        if (current.x === endTile.x && current.y === endTile.y) {\n            const path = [];\n            let currentTile = current;\n            while (currentTile) {\n                path.unshift({ x: currentTile.x, y: currentTile.y });\n                currentTile = currentTile.parent;\n            }\n            return path;\n        }\n        closedList.add(`${current.x},${current.y}`);\n        // Check all neighbors\n        for (const { x: dx, y: dy } of neighbors) {\n            const neighborX = current.x + dx;\n            const neighborY = current.y + dy;\n            // Check if the neighbor is within bounds and is not an obstacle (assuming 0 = walkable, 1 = obstacle)\n            if (neighborX >= 0 && neighborX < grid[0].length && neighborY >= 0 && neighborY < grid.length && grid[neighborY][neighborX] !== 0) {\n                const neighbor = {\n                    x: neighborX,\n                    y: neighborY,\n                    g: current.g + 1, // Assume cost to move to any neighbor is 1\n                    h: heuristic({ x: neighborX, y: neighborY, g: 0, h: 0, f: 0, parent: null }, { x: endCol, y: endRow, g: 0, h: 0, f: 0, parent: null }),\n                    f: 0,\n                    parent: current\n                };\n                if (closedList.has(`${neighbor.x},${neighbor.y}`)) {\n                    continue; // Skip if already evaluated\n                }\n                // Check if this neighbor is better (lower f) than any previously evaluated\n                if (!openList.some(tile => tile.x === neighbor.x && tile.y === neighbor.y)) {\n                    neighbor.f = neighbor.g + neighbor.h;\n                    openList.push(neighbor);\n                }\n            }\n        }\n    }\n    return []; // No path found\n}\nfunction heuristic(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n// Bresenham's Line Algorithm\nfunction bresenhamPath(startRow, startCol, endRow, endCol) {\n    const path = [];\n    let x = startCol;\n    let y = startRow;\n    const dx = Math.abs(endCol - startCol);\n    const dy = Math.abs(endRow - startRow);\n    const sx = startCol < endCol ? 1 : -1;\n    const sy = startRow < endRow ? 1 : -1;\n    let err = dx - dy;\n    while (x !== endCol || y !== endRow) {\n        path.push({ x, y });\n        const e2 = err * 2;\n        if (e2 > -dy) {\n            err -= dy;\n            x += sx;\n        }\n        if (e2 < dx) {\n            err += dx;\n            y += sy;\n        }\n    }\n    path.push({ y: endRow, x: endCol });\n    return path;\n}\nfunction drawPath() {\n    if (!selectedTile)\n        return;\n    if (!hoveredTile)\n        return;\n    if (!validMoveTiles)\n        return;\n    const path = astarPath(selectedTile.row, selectedTile.col, hoveredTile.row, hoveredTile.col);\n    for (const tile of path) {\n        if (validMoveTiles.find(validTile => validTile.row === tile.y && validTile.col === tile.x)) {\n            drawPathTile(tile.y, tile.x);\n        }\n    }\n}\nfunction drawPathTile(row, col) {\n    const frameSize = 32;\n    const highlightFrameX = 0;\n    const highlightFrameY = 4;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawMoveTile(row, col) {\n    validMoveTiles.push({ row, col });\n    if (!selectedTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = 3;\n    const highlightFrameY = 1;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawActionTiles() {\n    if (isAction) {\n        if (moveTile) {\n            const unit = units.find(unit => unit.row === moveTile.row && unit.col === moveTile.col);\n            if (unit) {\n                validActionTiles = [];\n                const range = unit.range;\n                const row = moveTile.row;\n                const col = moveTile.col;\n                let actionPerformed = false;\n                for (let i = -range; i <= range; i++) {\n                    for (let j = -range; j <= range; j++) {\n                        if (Math.abs(i) + Math.abs(j) <= range) {\n                            if (i === 0 && j === 0)\n                                continue;\n                            if (!hasUnit(row + i, col + j))\n                                continue;\n                            let action = unit.action;\n                            if (action === 'heal' && !unitIsTeam(row + i, col + j))\n                                continue;\n                            if (action === 'heal' && !unitCanBeHealed(row + i, col + j))\n                                continue;\n                            if (action === 'attack' && !unitCanBeAttacked(row + i, col + j))\n                                continue;\n                            if (action === 'attack' && unitIsTeam(row + i, col + j))\n                                continue;\n                            drawActionTile(row + i, col + j, action);\n                            actionPerformed = true;\n                        }\n                    }\n                }\n                if (!actionPerformed) {\n                    console.log(`Unit ${unit.id} has no valid actions`);\n                    unit.canAct = false;\n                    isAction = false;\n                    moveTile = null;\n                    window.socket.emit('force-unit-end-turn', unit.id);\n                }\n            }\n        }\n    }\n}\nfunction drawActionTile(row, col, action) {\n    validActionTiles.push({ row, col });\n    const frameSize = 32;\n    const highlightFrameX = action === 'attack' ? 2 : 1;\n    const highlightFrameY = 1;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    const pos = coordToPosition(row, col);\n    if (pos.x === -9999 || pos.y === -9999)\n        return;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, pos.x, pos.y - 8 * exports.SCALE, frameSize * exports.SCALE, frameSize * exports.SCALE);\n}\nfunction drawUnits() {\n    units.sort((a, b) => {\n        const posA = coordToPosition(a.row, a.col);\n        const posB = coordToPosition(b.row, b.col);\n        return posA.y - posB.y;\n    });\n    for (const unit of units) {\n        const frameSize = 32;\n        const frameX = unit.sprite.currentFrame;\n        const frameY = unit.currentStatus;\n        const sx = frameX * frameSize;\n        const sy = frameY * frameSize;\n        const pos = coordToPosition(unit.row, unit.col);\n        ctx.imageSmoothingEnabled = false;\n        let unitImage = new Image();\n        unitImage.src = `/assets/spritesheets/units/${unit.sprite.name}.png`;\n        ctx.drawImage(unitImage, sx, sy, frameSize, frameSize, pos.x, pos.y - frameSize * exports.SCALE + (8 * exports.SCALE), frameSize * exports.SCALE, frameSize * exports.SCALE);\n        //update the animation of the sprite\n        unit.sprite.framesElapsed++;\n        if (unit.sprite.framesElapsed % unit.sprite.framesHold === 0) {\n            if (unit.sprite.currentFrame < unit.sprite.idleFrames - 1) {\n                unit.sprite.currentFrame++;\n            }\n            else {\n                unit.sprite.currentFrame = 0;\n            }\n        }\n    }\n}\nfunction coordToPosition(row, col) {\n    for (const tile of tiles) {\n        if (tile.row === row && tile.col === col) {\n            return { x: tile.x, y: tile.y };\n        }\n    }\n    return { x: -9999, y: -9999 };\n}\n// -----------Touch Screen Logic---------------------------\n// let touchStartTime = 0;\n// const TAP_THRESHOLD = 200;\n// canvas.addEventListener('touchstart', function(e) {\n//     e.preventDefault(); // Prevent default touch behavior (like scrolling)\n//     if (e.touches.length !== 1) return; // Ensure it's a single touch\n//     touchStartTime = Date.now();\n//     isDragging = true;\n//     startX = e.touches[0].clientX - cameraOffsetX;\n//     startY = e.touches[0].clientY - cameraOffsetY;\n//     const touch = e.changedTouches[0];\n//     const clickX = touch.clientX - canvas.offsetLeft;\n//     const clickY = touch.clientY - canvas.offsetTop;\n//     let found = false;\n//     for (const tile of tiles) {\n//         if (!hoveredTile) break;\n//         if (isPointInsideTile(clickX, clickY, tile)) {\n//             //console.log(`You clicked on: ${tile.row}, ${tile.col}`);\n//             if (!selectedTile && unitIsTeam(hoveredTile.row, hoveredTile.col)) {\n//                 selectedTile = tile;\n//             } else if (selectedTile && tile.row === selectedTile.row && tile.col === selectedTile.col) {\n//                 const unit = units.find(unit => unit.row === selectedTile!.row && unit.col === selectedTile!.col);\n//                 console.log(`Moving to: ${tile.row}, ${tile.col}`);\n//                 window.socket.emit('player-unit-move', unit!.id, tile);\n//                 break;\n//             } else if (selectedTile && unitIsTeam(selectedTile.row, selectedTile.col)) {\n//                 const unit = units.find(unit => unit.row === selectedTile!.row && unit.col === selectedTile!.col);\n//                 console.log(`Moving to: ${tile.row}, ${tile.col}`);\n//                 window.socket.emit('player-unit-move', unit!.id, tile);\n//                 selectedTile = null;\n//             }\n//             found = true;\n//             break;\n//         }\n//     }\n//     if (!found) {\n//         selectedTile = null;\n//     }\n// });\n// let prevTouchDistance: number | null = null;\n// canvas.addEventListener('touchmove', function(e) {\n//     e.preventDefault();\n//     if (e.touches.length === 1) {\n//         if (!isDragging) return;\n//         const touchX = e.touches[0].clientX;\n//         const touchY = e.touches[0].clientY;\n//         cameraOffsetX = touchX - startX;\n//         cameraOffsetY = touchY - startY;\n//         // Update hovered tile (similar to mousemove)\n//         const clickX = touchX - canvas.offsetLeft;\n//         const clickY = touchY - canvas.offsetTop;\n//         for (const tile of tiles) {\n//             if (isPointInsideTile(clickX, clickY, tile)) {\n//                 hoveredTile = tile;\n//                 break;\n//             }\n//             else {\n//                 hoveredTile = null;\n//             }\n//         }\n//     }\n//     if (e.touches.length === 2) {\n//         // Get the coordinates of the two touch points\n//         const touch1X = e.touches[0].clientX;\n//         const touch1Y = e.touches[0].clientY;\n//         const touch2X = e.touches[1].clientX;\n//         const touch2Y = e.touches[1].clientY;\n//         // Calculate the current distance between the two touch points\n//         const currentDistance = Math.sqrt(\n//             (touch2X - touch1X) ** 2 + (touch2Y - touch1Y) ** 2\n//         );\n//         if (prevTouchDistance !== null) {\n//             // Calculate the scale factor based on the distance change\n//             const scaleChange = currentDistance / prevTouchDistance;\n//             // Apply the zoom (scale) adjustment\n//             if (scaleChange > 1) {\n//                 // Zoom in (scale up)\n//                 if (SCALE !== MAX_SCALE) SCALE *= 1.05;\n//                 if (SCALE > MAX_SCALE) SCALE = MAX_SCALE;\n//             } else {\n//                 // Zoom out (scale down)\n//                 if (SCALE !== MIN_SCALE) SCALE *= 0.95;\n//                 if (SCALE < MIN_SCALE) SCALE = MIN_SCALE;\n//             }\n//         }\n//         // Update the previous touch distance for the next move event\n//         prevTouchDistance = currentDistance;\n//     }\n// });\n// canvas.addEventListener('touchend', function(e) {\n//     isDragging = false;\n//     if (e.touches.length < 2) {\n//         prevTouchDistance = null;\n//     }\n// });\n// ---------------UI EVENTS--------------------------------------------------------\nendTurnBtn.addEventListener('click', function (e) {\n    window.socket.emit('force-end-turn');\n    selectedTile = null;\n    isAction = false;\n    moveTile = null;\n});\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/game.ts?");

/***/ }),

/***/ "./src/client/helpers.ts":
/*!*******************************!*\
  !*** ./src/client/helpers.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPointInsideTile = isPointInsideTile;\nconst game_1 = __webpack_require__(/*! ./game */ \"./src/client/game.ts\");\nfunction isPointInsideTile(px, py, tile) {\n    // Vertices of the tile\n    const x1 = tile.x, y1 = tile.y;\n    const x2 = tile.x + 16 * game_1.SCALE, y2 = tile.y + 8 * game_1.SCALE;\n    const x3 = tile.x + 32 * game_1.SCALE, y3 = tile.y;\n    const x4 = tile.x + 16 * game_1.SCALE, y4 = tile.y - 8 * game_1.SCALE;\n    // Helper function to calculate the area of a triangle given by three points\n    const sign = (x1, y1, x2, y2, x3, y3) => {\n        return (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);\n    };\n    // Check if the point is inside the tile (diamond shape)\n    const d1 = sign(px, py, x1, y1, x2, y2);\n    const d2 = sign(px, py, x2, y2, x3, y3);\n    const d3 = sign(px, py, x3, y3, x4, y4);\n    const d4 = sign(px, py, x4, y4, x1, y1);\n    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0) || (d4 < 0);\n    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0) || (d4 > 0);\n    // Point is inside the tile if all signs are the same (either all positive or all negative)\n    return !(hasNeg && hasPos);\n}\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/helpers.ts?");

/***/ }),

/***/ "./src/client/sprites.ts":
/*!*******************************!*\
  !*** ./src/client/sprites.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sprites = void 0;\nexports.sprites = [\n    {\n        name: \"test\",\n        image: \"test\",\n        idleFrames: 2,\n        currentFrame: 0,\n        framesElapsed: 0,\n        framesHold: 500,\n    }\n];\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/sprites.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/client/game.ts");
/******/ 	
/******/ })()
;