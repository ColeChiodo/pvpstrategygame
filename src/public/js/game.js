/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client/game.ts":
/*!****************************!*\
  !*** ./src/client/game.ts ***!
  \****************************/
/***/ (() => {

eval("\nconst MIN_SCALE = 1.0;\nconst MAX_SCALE = 5.0;\nlet SCALE = 3.125;\nlet arenaImage = null;\nlet arena = null;\nlet uiImage = new Image();\nuiImage.src = '/assets/spritesheets/UI.png';\nlet testUnitImage = new Image();\ntestUnitImage.src = '/assets/spritesheets/units/test.png';\nlet units = [];\nlet hoveredTile = null;\nlet selectedTile = null;\nlet actionTile = null;\nconst canvas = document.getElementById('gameCanvas');\nconst ctx = canvas.getContext('2d');\nfunction drawBackground() {\n    ctx.fillStyle = '#222034';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n}\nfunction drawArena() {\n    if (arenaImage) {\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(arenaImage, (canvas.width - arena.width * SCALE) / 2, (canvas.height - arena.height * SCALE + 16 * SCALE) / 2, arena.width * SCALE, arena.height * SCALE);\n    }\n}\nfunction draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    drawBackground();\n    drawArena();\n    drawUI();\n    drawUnits();\n    drawInteractionSquares();\n}\nwindow.addEventListener('keydown', (e) => {\n    console.log('Key pressed:', e.key);\n    window.socket.emit('player-action', e.key);\n    switch (e.key) {\n        case 'z':\n            if (SCALE !== MIN_SCALE)\n                SCALE -= 0.125;\n            break;\n        case 'x':\n            if (SCALE !== MAX_SCALE)\n                SCALE += 0.125;\n            break;\n    }\n});\nfunction loadUnits(players) {\n    units = [];\n    for (const player of players) {\n        for (const unit of player.units) {\n            unit.owner = player;\n            units.push(unit);\n        }\n    }\n}\nwindow.socket.on('gameState', (gameState) => {\n    console.log('Game State:', gameState);\n    loadArenaImage(gameState.arena); // move to a game start function in the future to only load once\n    loadUnits(gameState.players);\n});\nfunction gameLoop() {\n    draw();\n    requestAnimationFrame(gameLoop);\n}\ngameLoop();\nfunction loadArenaImage(newArena) {\n    if (!arenaImage) {\n        arenaImage = new Image();\n        arenaImage.src = `/assets/maps/${newArena.image}`;\n        arena = newArena;\n        arenaImage.onload = () => {\n            drawArena();\n        };\n    }\n}\nfunction resizeCanvas() {\n    canvas.width = window.outerWidth;\n    canvas.height = window.outerHeight;\n    draw();\n}\nresizeCanvas();\nwindow.addEventListener('resize', resizeCanvas);\nlet tiles = [];\nfunction drawInteractionSquares() {\n    if (!arenaImage)\n        return;\n    if (!arena)\n        return;\n    const tileWidth = 32 * SCALE; // width of an isometric tile\n    const tileHeight = 16 * SCALE; // height of an isometric tile\n    const rows = arena.tiles.length;\n    const cols = arena.tiles[0].length;\n    // get canvas center\n    const imgCenterX = canvas.width / 2;\n    const imgCenterY = canvas.height / 2;\n    // Calculate the total width and height of the grid\n    const gridWidth = (cols - 1) * tileWidth / 2; // Total width of the grid\n    const gridHeight = (rows - 1) * tileHeight / 2; // Total height of the grid\n    // Calculate the offset to center the grid on the image\n    const offsetX = imgCenterX - tileWidth / 2;\n    const offsetY = imgCenterY - gridHeight - tileHeight - 8 * SCALE;\n    // Draw the tiles\n    tiles = [];\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            // Calculate isometric coordinates\n            if (arena.tiles[row][col] === 0)\n                continue;\n            const isoX = (col - row) * tileWidth / 2 + offsetX;\n            const isoY = (col + row) * tileHeight / 2 + offsetY;\n            tiles.push(drawIsometricTile(isoX, isoY, row, col));\n        }\n    }\n}\nfunction drawIsometricTile(x, y, row, col) {\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + 16 * SCALE, y + 8 * SCALE);\n    ctx.lineTo(x + 32 * SCALE, y);\n    ctx.lineTo(x + 16 * SCALE, y - 8 * SCALE);\n    ctx.closePath();\n    ctx.stroke();\n    return { x, y, row, col };\n}\nfunction isPointInsideTile(px, py, tile) {\n    // Vertices of the tile\n    const x1 = tile.x, y1 = tile.y;\n    const x2 = tile.x + 16 * SCALE, y2 = tile.y + 8 * SCALE;\n    const x3 = tile.x + 32 * SCALE, y3 = tile.y;\n    const x4 = tile.x + 16 * SCALE, y4 = tile.y - 8 * SCALE;\n    // Helper function to calculate the area of a triangle given by three points\n    const sign = (x1, y1, x2, y2, x3, y3) => {\n        return (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);\n    };\n    // Check if the point is inside the tile (diamond shape)\n    const d1 = sign(px, py, x1, y1, x2, y2);\n    const d2 = sign(px, py, x2, y2, x3, y3);\n    const d3 = sign(px, py, x3, y3, x4, y4);\n    const d4 = sign(px, py, x4, y4, x1, y1);\n    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0) || (d4 < 0);\n    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0) || (d4 > 0);\n    // Point is inside the tile if all signs are the same (either all positive or all negative)\n    return !(hasNeg && hasPos);\n}\ncanvas.addEventListener('click', function (event) {\n    const clickX = event.offsetX;\n    const clickY = event.offsetY;\n    let found = false;\n    for (const tile of tiles) {\n        if (isPointInsideTile(clickX, clickY, tile)) {\n            console.log(`You clicked on: ${tile.row}, ${tile.col}`);\n            if (!selectedTile) {\n                selectedTile = tile;\n            }\n            else if (tile.row === selectedTile.row && tile.col === selectedTile.col) {\n                break;\n            }\n            else {\n                selectedTile = tile;\n            }\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        selectedTile = null;\n    }\n});\ncanvas.addEventListener('mousemove', function (event) {\n    const clickX = event.offsetX;\n    const clickY = event.offsetY;\n    for (const tile of tiles) {\n        if (isPointInsideTile(clickX, clickY, tile)) {\n            console.log(`You hovered on: ${tile.row}, ${tile.col}`);\n            hoveredTile = tile;\n            break;\n        }\n        else {\n            hoveredTile = null;\n        }\n    }\n});\nfunction hasUnit(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction unitIsTeam(row, col) {\n    for (const unit of units) {\n        if (unit.row === row && unit.col === col) {\n            return unit.owner.id === window.socket.id;\n        }\n    }\n    return false;\n}\nfunction drawHoveredTile() {\n    if (!hoveredTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = hasUnit(hoveredTile.row, hoveredTile.col) ? (unitIsTeam(hoveredTile.row, hoveredTile.col) ? 1 : 2) : 0;\n    const highlightFrameY = 0;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, hoveredTile.x, hoveredTile.y - 8 * SCALE, frameSize * SCALE, frameSize * SCALE);\n}\nfunction drawSelectedTile() {\n    if (!selectedTile)\n        return;\n    const frameSize = 32;\n    const highlightFrameX = 3;\n    const highlightFrameY = 0;\n    const sx = highlightFrameX * frameSize;\n    const sy = highlightFrameY * frameSize;\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(uiImage, sx, sy, frameSize, frameSize, selectedTile.x, selectedTile.y - 8 * SCALE, frameSize * SCALE, frameSize * SCALE);\n}\nfunction drawUI() {\n    drawHoveredTile();\n    drawSelectedTile();\n}\nfunction drawUnits() {\n    for (const unit of units) {\n        const frameSize = 48;\n        const frameX = 0;\n        const frameY = 0;\n        const sx = frameX * frameSize;\n        const sy = frameY * frameSize;\n        const pos = coordToPosition(unit.row, unit.col);\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(testUnitImage, sx, sy, frameSize, frameSize, pos.x - 8 * SCALE, pos.y - frameSize * SCALE + (3 * SCALE), frameSize * SCALE, frameSize * SCALE);\n    }\n}\nfunction coordToPosition(row, col) {\n    for (const tile of tiles) {\n        if (tile.row === row && tile.col === col) {\n            return { x: tile.x, y: tile.y };\n        }\n    }\n    return { x: 0, y: 0 };\n}\n\n\n//# sourceURL=webpack://pvpstrategygame/./src/client/game.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client/game.ts"]();
/******/ 	
/******/ })()
;